#include <bits/stdc++.h>

#define endl '\n'

using namespace std;
using ll = long long;

void solve() {
	int n;
	cin >> n;
	const int INF = n + 1;
	vector<int> dp(n + 1, INF);
	dp[0] = 0;
	vector<int> cubes;
	for (int i = 1; i * i * i <= n; ++i) {
		cubes.push_back(i * i * i);
	}
	for (int i = 0; i < n; ++i) {
		for (int v: cubes) {
			if (i + v > n) break;
			dp[i + v] = min(dp[i + v], dp[i] + 1);
		}
	}
	int ans = INF;
	cout << dp[n] << " " << ans << endl;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t = 1;
//	cin >> t;
	for (int i = 0; i < t; ++i) {
		solve();
	}
}

// B - вместо прибавления честно на всем отрезке, делаем только [l] += v, [r + 1] -= v, в конце преф суммы

// 5 4
//1 1 1
//3 5 4
//3 4 1
//1 5 -1

// 0 0 0 0 0 0

// 1 -1 0 0 0 0
// 1 -1 4 0 0 -4
// 1 -1 5 0 -1 -4
// 0 -1 5 0 -1 -3

// cur = 3

// 0 -1 4 4 3

// C - считаем для всех подотрезков максимум, но не каждый раз заново, а поддерживаем значение (по факту преф или суфф максимум)

// D - делаем в тупую преф суммами и замечаем что можно ускорить написав формулу

// (pref[1] - pref[0]) + (pref[2] - pref[0]) + (pref[3] - pref[0]) + ... = sum(pref) - pref[0] * n

// либо посчитать сколько подотрезков содержит какой-то элемент

// E - посчитаем сколько подпоследовательностей содержит элемент

// C(n, 0) + C(n, 1) + C(n, 2) + ... + C(n, n) = 2^n

// Понимаем, что таких 2^(n-1) [наш точно берем, а остальные как хотим]. Итого ответ это sum(a) * 2^(n-1)

// F выбираем момент когда покупаем или продаем и для него находим мин/макс позицию, но опять же не в тупую, а поддерживаем или суфф преф считаем честно

// G - два указателя. Фиксируем начало l. Тогда поддерживаем макс конец r
// l r
// q = r - l
// C(q, 2) = q * (q - 1) / 2

// (q - 1 + 1) * (q - 1) / 2 = q*(q - 1)/2

// H - объединяем отрезки сами или событиями
// I - событиями почти как на лекции, но ищем при этом макс
// J - совсем как лекция

// Про то как считать C:

// C(n, k) = C(n - 1, k - 1) + C(n - 1, k)

// n <= 10^4
// n = 2*10^5

// C = n! / (n - k)! * k!

// -1 % 1e9+7 = -1
// a = 4
// b = 5
// ((a - b) % MOD + MOD) % MOD = 1e9+6

// phi(n) - кол-во взаимнопростых чисел с n (< n конечно)
// phi(p) = p - 1

// a ^ phi(MOD) = 1
// 1/a = a ^ (phi(MOD) - 1)
// a ^ (phi(MOD) - 1) * a = a^phi(MOD) = 1
// 1 / a * a = 1

// MOD = 1e9+7

// a^(MOD - 2) == 1/a

// b / a = b * (1/a) = b * binpow(a, MOD - 2)

// fact(n)
// invfact(n)

// C(n, k) = fact[n] * invfact[n - k] * invfact[k]